---
title: Advent of Code 2022
tags:
  - blog
  - coding
  - advent
mathjax: false
article_header:
  type: cover
categories: blog
author: thomasburgess
description: Advent of code
---

# Advent of Code 2022

I will do this years [Advent of Code 2022](https://adventofcode.com/2022) in vanilla (only included libraries) python 3.10.4. 
I've joined the challenge a few times before - but never finished.
Let's see how many days I manage this round :D 

**NOTE**: This blog contains spoilers - use it responsibly. 

I've hidden the details for each day behind `expand details` blocks if you want to see only some solutions.

### Template

In general, these tasks require input data to be read in and be processed in two different parts. Here is the pathon template I use to get started:

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Advent of code day XX - """

def read_data(path: str) -> list:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(line)
    return result


def part1(data: list):
    return


def part2(data: list):
    return

if __name__ == "__main__":
    DAY = "XX"
    exdata = read_data(f"day{DAY}_example.txt")
    indata = read_data(f"day{DAY}_input.txt")

    print("PART 1")
    print("\texample", part1(exdata))
    print("\tinput", part1(indata))

    print("PART 2")
    print("\texample", part2(exdata))
    print("\tinput", part2(indata))
```

I'll keep my code on this [github repository](https://github.com/thomasburgess/advent2022), most of the code will appear in this blog post.

### Learnings

I learned a few useful things on these challenges so far:

* [`itertools.takewhile`](https://docs.python.org/3.8/library/itertools.html#itertools.takewhile) - Iterate while predicate is True 
- Transpose for list of lists: `tuple(zip(*data))`
- Like `sum(x)` but for products `functools.reduce(operator.mul, x, 1)`
* The use of [`functools.cmp_to_key`](https://docs.python.org/3/library/functools.html#functools.cmp_to_key) and key functions to change how `sort`, `max`, and similar functions work in python


## Day 01 - Counting calories

[Day 01 link](https://adventofcode.com/2022/day/1)

{% details Click to expand Day01 solution %}

Lines in a group have a single integer, blank lines separate groups.

```
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
```

`read_sums` parses the data, aggregates groups, and returns the list of sums.

```python
def read_sums(path):
    result = [0]  # Start with single empty sum
    with open(path, "r") as f:
        for line in f.readlines():
            if not line.strip():
                result.append(0)  # Add new empty sum
                continue
            result[-1] = result[-1] + int(line)
    return result
```

**Part 1** 

Task: Find the group with the largest sum.

Solution: Take the maximum of the list of sums

```python
max(read_sums("day01_input.txt"))
```

**Part 2** 

Task: Find the three largest groups. 

Solution: Sort the list and summing the last 3 items:

```python
sum(sorted(read_sums("day01_input.txt"))[-3:])
```

{% enddetails %}


## Day 02 - Rock Paper Scissors

[Day 02 link](https://adventofcode.com/2022/day/2)

{% details Click to expand Day02 solution %}

Data: rows with games, the first column is the opponent move, and the second is the player move.

Move encoding: Rock, paper, and scissors is A, B, C for opponent, and X, Y, Z for player.

```
A Y
B X
C Z
```

`read_strats` parses the data and converts character representation to 0, 1, 2

```python
def read_strats(path: str) -> list[int]:
    with open(path, "r") as f:
        return [
            (ord(i) - ord("A"), ord(j) - ord("X"))
            for i, j in (x.split() for x in f.readlines())
        ]
```

**Part 1** 

Task: Count score for rock paper scissors games.

Score: Player move (1 for rock, 2 for paper, and 3 for scissors), plus 0 for loss, 3 for draw and 6 for win.

The `score` function computes the score for a single game:

```python
def score(i, j):
    return j + 1 + [[3, 0, 6], [6, 3, 0], [0, 6, 3]][j][i]
```

With this the total score is

```python
def part1(strats: list[int]) -> int:
    return sum(map(lambda i: score(*i), strats))
```

**Part 2**

Task: count score as above but now the second column states X=loss, Y=draw, Z=win.

Using `transform` the second column is transformed to the old format:

```python
def transform(i, j):
    return [[2, 0, 1], [0, 1, 2], [1, 2, 0]][j][i]
```

and then the total score (using part1 on the transformed data) is

```python
def part2(strats: list[int]) -> int:
    return part1(map(lambda x: (x[0], transform(*x)), strats))
```

{% enddetails %}

## Day 03 - Rucksack Reorganization

[Day 03 link](https://adventofcode.com/2022/day/3)

{% details Click to expand Day03 solution %}

Each row of data is a rucksack with a string of characters `[a-zA-Z]`. 

```
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
```

Each character corresponds to a priority: a=1,..., z=27, A=27,..., Z=52.

```python
def priority(c: chr) -> int:
    return (ord(c) - ord("A") + 27) if c.isupper() else (ord(c) - ord("a") + 1)
```

With this sack data is read with `read_sacks`.

```python
def read_sacks(path: str)->list[list[int]]:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(priority, line.strip())))
    return result
```

**Part 1**

Task: sum priority of items unique in first and second half of rucksack. 

Part 1 is solved by summing the set intersections of the first and second part of the sacks:

```python
def part1(sacks: list[list[int]]) -> int:
    return sum(
        map(lambda x: sum(set(x[: len(x) // 2]).intersection(x[len(x) // 2 :])), sacks)
    )

```

**Part 2**

Task: sum priority of items unique to three consecutive rucksacks.

This part is solved by summing the intersections of  consecutive sacks, as follows:

```python
def part2(sacks: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: sum(
                set(sacks[x]).intersection(sacks[x + 1]).intersection(sacks[x + 2])
            ),
            range(0, len(sacks), 3),
        )
    )
```

{% enddetails %}

## Day 04 - Camp Cleanup

[Day 04 link](https://adventofcode.com/2022/day/4)

{% details Click to expand Day04 solution %}

Each row shows a pair separated by `,`, each entry is a range `low-high`.

```
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
```

With this sack data is read with `read_pairs`.

```python
def read_pairs(path: str):
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(int, line.replace("-", ",").split(","))))
    return result
```

**Part 1**

Task: Count pairs where one pair fully overlaps with the other

Solution: check if one pair overlaps the other in either order.

```python
def count_contained(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[2] >= x[0] and x[3] <= x[1])
            or (x[0] >= x[2] and x[1] <= x[3]),
            pairs,
        )
    )
```

**Part 2**

Task: Count overlapping pairs

Solution: Check if range bounds overlap in any way

```python
def count_overlaps(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[1] >= x[2] and x[1] <= x[3])
            or (x[3] >= x[0] and x[3] <= x[1]),
            pairs,
        )
    )
```

{% enddetails %}

## Day 05 - Supply Stacks

[Day 05 link](https://adventofcode.com/2022/day/5)

For me the whole challenge here was to parse the data.

{% details Click to expand Day05 solution %}

The data is split into two parts separated by a blank line. In the first part, stacks of items are listed in columns, with column index on the last row (this index can be ignored). Items are on the form `[X]` where `X` is a single character item id. In the second part a sequence of moves with item count count, source column, destination column are listed.

```
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
```

The two parts are read in and processed with `read_stacks`:

```python
def read_stacks(path: str) -> tuple[dict[int, list[chr]], list[list[int]]]:
    stacks = defaultdict(list)
    moves = []
    with open(path, "r") as f:
        lines = f.readlines()

        # Read stacks
        for j, line in enumerate(lines):
            if line == "\n":
                break
            for i in range(len(line) // 4):
                stacks[i].append(re.sub("[^A-Za-z]+", "", line[i * 4 : i * 4 + 4]))

        # Read moves
        for line in lines[j + 1 :]:
            moves.append([int(i) for i in re.sub("[^0-9]+", " ", line).split()])

    return {k + 1: [i for i in v if i] for k, v in stacks.items()}, moves
```

**Part 1**

Task: apply the moves and list the top item in the stack

The moves are applied in sequence using `apply_moves`.

```python
def apply_moves(
    stacks: dict[int, list[chr]], moves: list[list[int]], reverse: bool
) -> str:
    for n, s, d in moves:
        sub = stacks[s][:n]
        stacks[d] = (sub[::-1] if reverse else sub) + stacks[d]
        stacks[s] = stacks[s][n:]
    return "".join([v[0] for k, v in stacks.items()])
```

The reverse option is used to reorder the stack to work with the specification. For this task `reverse=True`.

**Part 2**

Task: same but with different ordering of added items.

This is solved with the same `apply_moves` function with `reverse=False`.

{% enddetails %}

## Day 06 - Tuning Trouble

[Day 06 link](https://adventofcode.com/2022/day/6)

{% details Click to expand Day06 solution %}

5 examples are given:

```
7 mjqjpqmgbljsphdztnvjfqwrcgsmlb
5 bvwbjplbgvbhsrlpgdmjqwftvncz
6 nppdvjthqldpwncqszvftbrmjlhg
10 nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg
11 zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw
```

Task: find message start - the first instance of four different consecutive characters.

Solution: generate the length of the `set` of n character spans until it equals n. For this [`itertools.takewhile`](https://docs.python.org/3.8/library/itertools.html#itertools.takewhile) is very useful.

```python
from itertools import takewhile
def find_start(message: str, n: int) -> int:
    return n + sum(
        1
        for _ in takewhile(
            lambda x: x != n,
            map(lambda x: len(set(message[x - n : x])), range(n, len(message))),
        )
    )
```
Plugging in `n=4` into this gives the correct solution for part 1, and part 2 likewise with `n=14`.

{% enddetails %}

## Day 07 - No Space Left On Device

[Day 07 link](https://adventofcode.com/2022/day/7)

{% details Click to expand Day07 solution %}

A file system is explored using `cd` and `ls`. The first `cd` is always to `/` and `ls` are always in current directory. Lines with commands starts with `$`. Listings of directories start with `dir`, and listings of file starts with file size.

```
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
```

The code is read into a tree strucutre of nested dictionaries using `read_tree`. For files the value is the filesize int instead of a dictionary. I based the thinking here on my [Tree Hack blog post](https://thomasburgess.github.io/blog/2021/07/18/tree_hack.html).

```python
def read_tree(path: str) -> dict:
    tree = {}
    cwd = []
    with open(path, "r") as f:
        t = tree
        for line in f.readlines()[1:]:
            split = line.split()
            if split[0] != "$":
                # Add file or directory
                t[split[1]] = {} if split[0] == "dir" else int(split[0])
            elif split[1] == "cd":
                dest = line.split()[-1]
                # Update current working directory
                cwd = cwd[:-1] if dest == ".." else (cwd + [dest])
                t = tree
                for c in cwd:  # Jump to the right directory in the tree
                    t = t[c]
    return tree
```

with the tree structure in place, one can traverse the tree and collect the total size of each directory. 

```python
def dir_size(tree: dict, base: str = "/") -> dict:
    result = {base: 0}
    for k, v in tree.items():
        if isinstance(v, int):
            result[base] += v
            continue
        key = base + "/" + k
        t = dir_size(v, base=key)
        result.update(t)
        result[base] += t[key]
    return result
```

The data input for the problems is the output of `dir_size(read_data("input.txt"))`.

**Part 1** 

Task 1: Find sum of directory sizes less than 100000

Solution: sum sizes ignoring anything smaller than the threshold:

```python
def part1(data: dict, thresh=100000) -> int:
    return sum(v for k, v in data.items() if v < 100000)
```

**Part 2**

Task 2: Find smallest directory that when removed leaves 30000000 free storage of a total of 70000000.

Solution: Take smallest element of items where `70000000-used+size>30000000`

```python
def part2(data: dict, total=70000000, req=30000000) -> int:
    return min(v for k, v in data.items() if total - data["/"] + v > req)
```

{% enddetails %}

## Day 08 - Treetop Tree House

[Day 08 link](https://adventofcode.com/2022/day/8)

{% details Click to expand Day08 solution %}

Data are heights of trees on a square grid.

```
30373
25512
65332
33549
35390
```

The maps are read into a list of list of ints.

```python
def read_map(path: str) -> tuple[tuple[int]]:
    """Read in data into 2D int array"""
    with open(path, "r") as f:
        return tuple(tuple(map(int, i.strip())) for i in f.readlines())
```

**Part 1** 

Task: Count number of visible trees from the edge.

Trees are not visible if behind trees of same or lower height.
The count is found as the sum of True values in a visibility matrix 
made by OR-ing together partial visibility matrices for each direction.

```python
def T(data: tuple[tuple[int]]) -> tuple[tuple[int]]:
    """Transpose list of lists"""
    return tuple(zip(*data))


def vor(x: list[bool], y: list[bool]) -> list[bool]:
    """Elementwise or of lists x and y"""
    return tuple(i or j for i, j in zip(x, y))


def vx(x: tuple[int]) -> tuple[bool]:
    """Visibility for each element in row x"""
    return [True] + [all(j < x[i] for j in x[:i]) for i in range(1, len(x))]


def vis(data: tuple[tuple[int]]) -> tuple[tuple[bool]]:
    """Visibilities for both directions in each row in data"""
    return tuple(vor(vx(x), vx(x[::-1])[::-1]) for x in data)


def visibility(data: tuple[tuple[int]]) -> tuple[tuple[bool]]:
    """Visibility ORed for rows and columns in data"""
    return tuple(vor(i, j) for i, j in zip(vis(data), T(vis(T(data)))))


def sum_visibility(data: tuple[tuple[int]]) -> int:
    """Sum visibilities"""
    return sum(sum(i) for i in visibility(data))
```

**Part 2**

Task: find maximum scenic score (product number of tree visible in each direction)

Here, for each tree the number of consecutive shorter trees is counted and multiplied together for each direction. 

This task took quite some time to debug, I think I didn't parse the instructions correctly...

```python
def count(v0: int, v: list[int]) -> int:
    """Count trees"""
    n = 0
    for x in v:
        n += 1
        if v0 <= x:
            break
    return n


def scenic(data: tuple[tuple[int]]) -> int:
    """Compute scenic score for each tree"""
    scenic_scores = dict()
    data_t = T(data)
    r = len(data)
    c = len(data[0])
    maxx = 0
    for i in range(r):
        for j in range(c):
            x = data[i][j]
            maxx = max(
                maxx,
                count(x, data[i][:j][::-1])
                * count(x, data[i][j + 1 : c])
                * count(x, data_t[j][:i][::-1])
                * count(x, data_t[j][i + 1 : r]),
            )
    return maxx
```

{% enddetails %}

## Day 09 - Rope Bridge

[Day 09 link](https://adventofcode.com/2022/day/9)

{% details Click to expand Day09 solution %}

Input data consists of moves with a direction (U,D,R,L) and a number of steps

```
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
```

The task is to move the head of a rope according to the moves, and track how the tail trails.

```python
def read_moves(path: str) -> list[tuple[str, int]]:
    with open(path, "r") as f:
        return list(
            map(lambda x: (x[0], int(x[1])), (line.split() for line in f.readlines()))
        )
```

The solution for part2 also solves part1 so I refactored simualte accordingly. As I had several bugs, I added a handy printer function to print the rope and locations visited by the tile:

```python
def printer(x: list[list[int]], hashes: bool = False):
    c = ["#" if hashes else str(i) for i in range(len(x))]
    if not hashes:
        c[0] = "H"
    sx = [s[0] for s in x]
    minx, maxx = min(sx), max(sx)
    sy = [s[1] for s in x]
    miny, maxy = min(sy), max(sy)
    for j in list(range(miny, maxy + 1))[::-1]:
        print(
            "".join(
                [
                    c[x.index([i, j])] if [i, j] in x else "."
                    for i in list(range(minx, maxx + 1))[::-1]
                ]
            )
        )
```

The simulation is fairly straight forward, once you decode the instructions...

```python
def sign(x: int) -> int:
    return (x > 0) - (x < 0)

def simulate(data, n=9, show=False):
    x = [[0, 0] for i in range(n + 1)]
    DELTA = {"U": (0, 1), "D": (0, -1), "R": (-1, 0), "L": (1, 0)}
    visited = {(0, 0)}
    for direction, steps in data:
        if show:
            print(f"=== {direction} {steps} ===")
        d = DELTA[direction]
        for step in range(steps):
            # Update head
            x[0] = [x[0][0] + d[0], x[0][1] + d[1]]
            # Update tail
            for i in range(1, len(x)):
                dt = [x[i - 1][0] - x[i][0], x[i - 1][1] - x[i][1]]
                if abs(dt[0]) > 1 or abs(dt[1]) > 1:
                    x[i][0] += sign(dt[0])
                    x[i][1] += sign(dt[1])
            visited.add(tuple(x[-1]))
        if show:
            printer(x)
    if show:
        print("VISITED")
        printer(list(list(x) for x in visited), hashes=True)
    return len(visited)
```

With this code the solutions are comptuted by running:

```python
print("part 1:", read_moves("input.txt"), 1)
print("part 2:",read_moves("input.txt"), 9)
```

{% enddetails %}

The printer gives this expected output for the tail visits for the longer example in part 2.
```
#.....................
#.............###.....
#............#...#....
.#..........#.....#...
..#..........#.....#..
...#........#.......#.
....#......#.........#
.....#..............#.
......#............#..
.......#..........#...
........#........#....
.........########.....
```


## Day 10 - Cathode-Ray Tube

[Day 10 link](https://adventofcode.com/2022/day/10)

{% details Click to expand Day10 solution %}

Data is instruction lists with `noop` (takes 1 cycle) and `addx` (takes 2 cycles). `addx dx` adds `dx` to the register x.

```
noop
addx 3
addx -5
```

The data is parsed to `cycle` count and `dx` for each instruction in `read_program`.

```python
def read_program(path: str) -> list[tuple[int, int]]:
    with open(path, "r") as f:
        return [
            (1 if "noop" in l else 2, 0 if "noop" in l else int(l.split()[1]))
            for l in f.readlines()
        ]
```

Next, the program is executed using `run_program`to track `cycle` count and `x` after each instructions. `x` starts at 1.

```python
def run_program(prog: list[tuple[int, int]], x: int = 1) -> list[tuple[int, int]]:
    y = [[0, x]]
    for dt, dx in prog:
        y.append((y[-1][0] + dt, y[-1][1] + dx))
    return y
```

**Part 1**

Task: Get cycle count * x for every 40th cycle starting at 20

The result is obtained by applying `part1` to the output of `run_program`.

```python
def part1(out: list[tuple[int, int]]) -> int:
    result = 0
    for q in range(20, out[-1][0], 40):
        *_, x = (q * v for (t, v) in out if t < q)
        result += x
    return result
```

**Part 2**

Task: Draw pixels when x is within +-1 of cycle MOD 40.

The result is obtained by applying `part2` to the output of `run_program`.

```python
def part2(prog: list[tuple[int, int]]) -> str:
    idx = 0
    result = [" "] * 240
    for s in range(240):
        r, c = divmod(s, 40)
        if prog[idx][1] - 1 <= c <= prog[idx][1] + 1:
            result[s] = "█"
        if s > prog[idx][0]:
            idx += 1
    return "\n".join("".join(result[i * 40 : (i + 1) * 40]) for i in range(6))
```

{% enddetails %}

This part is very satisfying as you get nice output! For the example:
```
██  ██  ██  ██  ██  ██  ██  ██  ██  ██
███   ███   ███   ███   ███   ███   ███
████    ████    ████    ████    ████
█████     █████     █████     █████
██████      ██████      ██████      ████
███████       ███████       ███████
```

and for my input:

```
███  ████ ███   ██  ████ ████   ██ ███
█  █    █ █  █ █  █    █ █       █ █  █
█  █   █  ███  █      █  ███     █ ███
███   █   █  █ █ ██  █   █       █ █  █
█    █    █  █ █  █ █    █    █  █ █  █
█    ████ ███   ███ ████ ████  ██  ███
```

## Day 11 - Monkey in the Middle

[Day 11 link](https://adventofcode.com/2022/day/11)

{% details Click to expand Day11 solution %}

Monkeys process their stack of worries and perform an operation on them, divides the results, and passes it on to another monkey depending on divisibility. 

```
Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

...
```

I read the data with the `read_monkey`. This function defines the operation and test as lambdas to be applied later. If `divby` is 1 the `//` at the end of the operation is avoided altogether (useful in part 2). Inspected is a counter that should be incremented for every action the monkey takes.

```python
def read_monkeys(path: str, divby: int = 3) -> list[dict]:
    result = []
    with open(path, "r") as f:
        for monkey in f.read().split("\n\n"):
            monkey_data = [m.strip() for m in monkey.split("\n") if m.strip()]

            result.append(
                {
                    "monkey": int(monkey_data[0].replace(":", "").split()[-1]),
                    "stack": list(
                        map(
                            int,
                            monkey_data[1].replace("Starting items: ", "").split(","),
                        )
                    ),
                    "inspected": 0,
                    "mod": int(monkey_data[3].replace("Test: divisible by ", "")),
                    "operation": eval(
                        "lambda x: ("
                        + monkey_data[2]
                        .replace("Operation: new = ", "")
                        .replace("old", "x")
                        + ")"
                        + ("" if divby == 1 else f"//{divby}")
                    ),
                    "test": eval(
                        f"lambda x: ({int(monkey_data[4].split()[-1]), int(monkey_data[5].split()[-1])})"
                        f"[x % {int(monkey_data[3].replace('Test: divisible by ', ''))} != 0]"
                    ),
                }
            )
    return result
```

In `run_monkeys` each monkey is evaulated in several rounds. The `mod` argument keeps worry from going too large in part2.

```python
def run_monkeys(monkeys: list[dict], rounds=20, mod=1):
    for r in range(rounds):
        for m in monkeys:
            while m["stack"]:
                m["inspected"] += 1
                i = m["stack"].pop(0)
                x = m["operation"](i)
                monkeys[m["test"](x)]["stack"].append(x % mod)
    return monkeys
```

**Part 1**

Find the product of the inspection count of the two busiest monkeys after 20 rounds, using `divby=3`.

```python
def prod(x):
    return reduce(operator.mul, x, 1)

def monkey_biz(monkeys: list[dict]):
    return prod(sorted([m["inspected"] for m in monkeys], reverse=True)[:2])

print("Part 1: ", monkey_biz(run_monkeys(read_monkeys("input.txt", divby=3), rounds=20)))
```

**Part 2**

The initial version of part1 was very very slow, I never bothered running it for more than 800 rounds. This is because the worries becomes huge. The solution is to apply the modulus product over all monkeys, using the `mod` setting in `run_monkeys` (I had to consult some forums to get that right). 

```python
mod = prod([m["mod"] for m in monkeys])
monkeys = run_monkeys(monkeys=monkeys, rounds=rounds, mod=mod)
print("Part 2:", monkey_biz(monkeys))
```

{% enddetails %}

## Day 12 - Hill Climbing Algorithm

[Day 12 link](https://adventofcode.com/2022/day/12)

This was easily my favourite entry so far!

{% details Click to expand Day12 solution %}

The data is a heightfield, with height as char: a(lowest) to z(highest). The path starts at S (height=a), and ends at E (height=z).

```
Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
```

The function `read_map` parses the input integer heights (with a=0), extracts the start and end point, and gets the map size m x n. With `make_graph` the map is turned into an adjeceny graph, ensuring map bounds are kept and no steps are taken up more than 1 height unit. With this, `bfs` is implemented - a vanilla 
[Breadth First Search](https://en.wikipedia.org/wiki/Breadth-first_search) to find the shortest path from S to E. I found the [deque](https://docs.python.org/3/library/collections.html#collections.deque) being sufficiently fast for both parts.

```python
import collections

def read_map(path: str):
    with open(path, "r") as f:
        data = [[ord(j) for j in i.strip()] for i in f.readlines()]
        n, m = len(data), len(data[0])
        start = next(
            (i, data[i].index(ord("S"))) for i in range(n) if ord("S") in data[i]
        )
        end = next(
            (i, data[i].index(ord("E"))) for i in range(n) if ord("E") in data[i]
        )
        data[start[0]][start[1]] = ord("a")
        data[end[0]][end[1]] = ord("z")
        data = [
            [data[i][j] - ord("a") for j in range(m)] for i in range(n)
        ]  # subtract a
    return data, start, end, n, m

def make_graph(data, n, m):
    graph = {}
    for i in range(n):
        for j in range(m):
            graph[(i, j)] = set(
                c
                for c in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]
                if 0 <= c[0] < n
                and 0 <= c[1] < m
                and data[c[0]][c[1]] - data[i][j] <= 1
            )
    return graph

def bfs(graph, start, end):
    if start == end:
        return [start]
    done = {start}
    queue = collections.deque([(start, [])])
    while queue:
        c, path = queue.popleft()
        done.add(c)
        for n in graph[c]:
            if n == end:
                return path + [c, n]
            if n in done:
                continue
            queue.append((n, path + [c]))
            done.add(n)
    return None
```

**Part 1**

Part one is solved by the following code:

```python
def part1(path):
    data, start, end, n, m = read_map(path)
    graph = make_graph(data, n, m)
    sol = bfs(graph, start, end)
    return len(sol) - 1
```

This is what the solution looks like:

{% figure [caption:"Figure 1: Solution to part 1."] %}
![](/assets/images/2022-12-01/day12_input_part1.png){: #figure-1 width="95%" alt="Solution ot part 1."}
{% endfigure %}

**Part 2**

In part 2, any point at height `a` is used as the starting point.

```python
def part2(path):
    data, start, end, n, m = read_map(path)
    graph = make_graph(data, n, m)
    best = None
    for start in [g for g in graph if data[g[0]][g[1]] == 0]:
        sol = bfs(graph, start, end)
        if not sol:
            continue
        if not best or len(sol) < best:
            best = len(sol) - 1
    return best - 1
```

{% enddetails %}

This is what the solution looks like:

{% figure [caption:"Figure 2: Part 2: The yellow path is the shortest path, the red are candidates."] %}
![](/assets/images/2022-12-01/day12_input_part2.png){: #figure-2 width="95%" alt="Solution ot part 2."}
{% endfigure %}


## Day 13 - Distress Signal

[Day 13 link](https://adventofcode.com/2022/day/13)

{% details Click to expand Day13 solution %}

Data are pairs of nested lists separated by blanks

```
[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]
```

This data is parsed to python lists in `read_pairs`.

```python
def read_pairs(path: str) -> list:
    with open(path, "r") as f:
        lines = f.readlines()
        return [
            list(map(eval, (lines[i], lines[i + 1])))
            for i in range(0, len(lines), 3)
        ]
```

**Part 1**

Task: compare pairs, and print the sum of indices of the pairs that are in order, as done in `part1`. 

The comparison is done in `compare`. If anything is found in or out of order the comparison stops and returns the results. Pairs of `int` are in order if `left < right` and out of order `right < left`. List pairs are iterated over sequentially, integer items are compared like above, and the procedure is recursed for list items. Mixed pairs are comnverted to list pairs. If the left list still has items remaining the pair is ìn order, and if the right list still has items remaining it is out of order.

```python
def compare(left, right):
    for l, r in zip(left, right):
        ints = tuple(map(lambda x: isinstance(x, int), (l, r)))
        if all(ints):
            if r == l:
                continue
            return l < r
        result = compare([l] if ints[0] else l, [r] if ints[1] else r)
        if result is not None:
            return result
    if len(left) == len(right):
        return
    return len(left) < len(right)

def part1(pairs):
    return sum(i for i, pair in enumerate(pairs, 1) if compare(pair[0], pair[1]))
```

**Part 2**

Task: flatten pairs, add items `[[2]]` and `[[6]]`, sort according to `compare`, and find the product of indices of `[[2]]` and `[[6]]`.

Here I use [`functools.cmp_to_key`](https://docs.python.org/3/library/functools.html#functools.cmp_to_key) to turn `compare` into a  [key function](https://docs.python.org/3/glossary.html#term-key-function).


```python
import functools
import operator

def prod(x):
    return functools.reduce(operator.mul, x, 1)

def part2(pairs):
    q = sorted(
        [i for p in pairs for i in p] + [[[2]], [[6]]],
        key=functools.cmp_to_key(lambda left, right: -compare(left, right)),
    )
    return prod([i for i, c in enumerate(q, 1) if c in ([[2]], [[6]])])
```

Somehow my comparator only works in negative, but it does work :)

{% enddetails %}

## Day 14 - Regolith Reservoir

[Day 14 link](https://adventofcode.com/2022/day/14)

{% details Click to expand Day14 solution %}

Data represents a map with obstacles givens as vertical or horizontal line segments:

```
498,4 -> 498,6 -> 496,6
503,4 -> 502,4 -> 502,9 -> 494,9
```

In `read_map` this data is read in and transformed into a list of lines, each consisting of list of segments.

```python
def read_map(path: str) -> list[list[tuple[int, int]]]:
    result = []
    with open(path, "r") as f:
        return [
            [tuple(map(int, x.split(","))) for x in line.split("->")]
            for line in f.readlines()
        ]
```

This can easily by plotted with matplotlib as a [LineCollection](https://matplotlib.org/stable/api/collections_api.html#matplotlib.collections.LineCollection)

```python
def plot_map(ax, data):
    ax.add_collection(LineCollection(data))
    ax.autoscale_view()  # See comment above, after ax1.add_collection.
    ax.set(ylim=ax.get_ylim()[::-1])
    ax.set_aspect('equal', 'box')

fig, ax = plt.subplots(figsize=(12, 8))
plot_map(ax, indata)
fig.tight_layout()
```
(plotting is not part of my solution, I allow myself use of external libraries for illustration :D)

{% figure [caption:"Figure 1: Map from input data."] %}
![](/assets/images/2022-12-01/day14_map.png){: #figure-1 width="241px" alt="Map from input data."}
{% endfigure %}

At (500,0) sand grains are produced and fall one at a time until they come to rest.
Grains try to fall down, if down is blocked they go down-left, 
if that also is blocked down-right, and if everything is blocked it stops.


**Part 1**

Task: How many units of sand come to rest before sand starts flowing into the abyss below?

**Part 2**

**Not yet**

{% enddetails %}

## Day 15 -

**Not yet**
