---
title: Advent of Code 2022
tags:
  - blog
  - coding
  - advent
mathjax: false
article_header:
  type: cover
categories: blog
author: thomasburgess
description: Advent of code
---

# Advent of Code 2022

I will do this years [Advent of Code 2022](https://adventofcode.com/2022) in vanilla python 3.10.4. I've done this a few times before, let's see how many days I manage this round :D This blog contains spoilers - use it responsibly.

In general these task requires some input data to be read in and be processed in two different parts. Here is the pathon template I use to get started:

{% details Click to expand template code... %}
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Advent of code day XX - """

def read_data(path: str) -> list:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(line)
    return result

if __name__ == "__main__":
    exdata = read_data("dayXX_example.txt")
    indata = read_data("dayXX_input.txt")

    print("PART 1")
    print("example", part1(exdata))
    print("input", part1(indata))

    print("PART 2")
    print("example", part2(exdata))
    print("input", part2(indata))
```
{% enddetails %}

I'll keep my code on this [github repository](https://github.com/thomasburgess/advent2022). 

## Learnings

I learned a few useful things on these challenges so far:

* [`itertools.takewhile`](https://docs.python.org/3.8/library/itertools.html#itertools.takewhile) - Iterate while predicate is True 
- Transpose for list of lists: `tuple(zip(*data))`

## Day 01 - Counting calories

[Day 01 link](https://adventofcode.com/2022/day/1)

Lines in a group have a single integer, blank lines separate groups.

{% details Click to expand `example data` python code... %}
```
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
```
{% enddetails %}


`read_sums` parses the data, aggregates groups, and returns the list of sums.

{% details Click to expand `read_sums` python code... %}
```python
def read_sums(path):
    result = [0]  # Start with single empty sum
    with open(path, "r") as f:
        for line in f.readlines():
            if not line.strip():
                result.append(0)  # Add new empty sum
                continue
            result[-1] = result[-1] + int(line)
    return result
```
{% enddetails %}

**Part 1** 

Task: Find the group with the largest sum.

Solution: Take the maximum of the list of sums

```python
max(read_sums("day01_input.txt"))
```

**Part 2** 

Task: Find the three largest groups. 

Solution: Sort the list and summing the last 3 items:

```python
sum(sorted(read_sums("day01_input.txt"))[-3:])
```

## Day 02 - Rock Paper Scissors

[Day 02 link](https://adventofcode.com/2022/day/2)

Data: rows with games, the first column is the opponent move, and the second is the player move.

Move encoding: Rock, paper, and scissors is A, B, C for opponent, and X, Y, Z for player.

{% details Click to expand example data... %}
```
A Y
B X
C Z
```
{% enddetails %}

`read_strats` parses the data and converts character representation to 0, 1, 2

{% details Click to expand `read_strats` python code... %}
```python
def read_strats(path: str) -> list[int]:
    with open(path, "r") as f:
        return [
            (ord(i) - ord("A"), ord(j) - ord("X"))
            for i, j in (x.split() for x in f.readlines())
        ]
```
{% enddetails %}

**Part 1** 

Task: Count score for rock paper scissors games.

Score: Player move (1 for rock, 2 for paper, and 3 for scissors), plus 0 for loss, 3 for draw and 6 for win.

The `score` function computes the score for a single game:

{% details Click to expand `score` python code... %}
```python
def score(i, j):
    return j + 1 + [[3, 0, 6], [6, 3, 0], [0, 6, 3]][j][i]
```
{% enddetails %}

With this the total score is

```python
def part1(strats: list[int]) -> int:
    return sum(map(lambda i: score(*i), strats))
```

**Part 2**

Task: count score as above but now the second column states X=loss, Y=draw, Z=win.

Using `transform` the second column is transformed to the old format:

{% details Click to expand `transform` python code... %}
```python
def transform(i, j):
    return [[2, 0, 1], [0, 1, 2], [1, 2, 0]][j][i]
```
{% enddetails %}

and then the total score (using part1 on the transformed data) is

```python
def part2(strats: list[int]) -> int:
    return part1(map(lambda x: (x[0], transform(*x)), strats))
```

## Day 03 - Rucksack Reorganization

[Day 03 link](https://adventofcode.com/2022/day/3)

Each row of data is a rucksack with a string of characters `[a-zA-Z]`. 

{% details Click to expand example data... %}
```
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
```
{% enddetails %}

Each character corresponds to a priority: a=1,..., z=27, A=27,..., Z=52.

{% details Click to expand `priority` python code... %}
```python
def priority(c: chr) -> int:
    return (ord(c) - ord("A") + 27) if c.isupper() else (ord(c) - ord("a") + 1)
```
{% enddetails %}

With this sack data is read with `read_sacks`.

{% details Click to expand `read_sacks` python code... %}
```python
def read_sacks(path: str)->list[list[int]]:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(priority, line.strip())))
    return result
```
{% enddetails %}

**Part 1**

Task: sum priority of items unique in first and second half of rucksack. 

Part 1 is solved by summing the set intersections of the first and second part of the sacks:

{% details Click to expand `part1` python code... %}
```python
def part1(sacks: list[list[int]]) -> int:
    return sum(
        map(lambda x: sum(set(x[: len(x) // 2]).intersection(x[len(x) // 2 :])), sacks)
    )

```
{% enddetails %}


**Part 2**

Task: sum priority of items unique to three consecutive rucksacks.

This part is solved by summing the intersections of  consecutive sacks, as follows:

{% details Click to expand `part2` python code... %}
```python
def part2(sacks: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: sum(
                set(sacks[x]).intersection(sacks[x + 1]).intersection(sacks[x + 2])
            ),
            range(0, len(sacks), 3),
        )
    )
```
{% enddetails %}

## Day 04 - Camp Cleanup

[Day 04 link](https://adventofcode.com/2022/day/4)

Each row shows a pair separated by `,`, each entry is a range `low-high`.

{% details Click to expand example data... %}
```
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
```
{% enddetails %}

With this sack data is read with `read_pairs`.

{% details Click to expand `read_pairs` python code... %}
```python
def read_pairs(path: str):
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(int, line.replace("-", ",").split(","))))
    return result
```
{% enddetails %}


**Part 1**

Task: Count pairs where one pair fully overlaps with the other

Solution: check if one pair overlaps the other in either order.

{% details Click to expand `count_contained` python code... %}
```python
def count_contained(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[2] >= x[0] and x[3] <= x[1])
            or (x[0] >= x[2] and x[1] <= x[3]),
            pairs,
        )
    )
```
{% enddetails %}

**Part 2**

Task: Count overlapping pairs

Solution: Check if range bounds overlap in any way

{% details Click to expand `count_contained` python code... %}
```python
def count_overlaps(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[1] >= x[2] and x[1] <= x[3])
            or (x[3] >= x[0] and x[3] <= x[1]),
            pairs,
        )
    )
```
{% enddetails %}

## Day 05 - Supply Stacks

[Day 05 link](https://adventofcode.com/2022/day/6)

The data is split into two parts separated by a blank line. In the first part, stacks of items are listed in columns, with column index on the last row (this index can be ignored). Items are on the form `[X]` where `X` is a single character item id. In the second part a sequence of moves with item count count, source column, destination column are listed.

{% details Click to expand example data... %}
```
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
```
{% enddetails %}

The two parts are read in and processed with `read_stacks`:

{% details Click to expand `read_stacks` python code... %}

```python
def read_stacks(path: str) -> tuple[dict[int, list[chr]], list[list[int]]]:
    stacks = defaultdict(list)
    moves = []
    with open(path, "r") as f:
        lines = f.readlines()

        # Read stacks
        for j, line in enumerate(lines):
            if line == "\n":
                break
            for i in range(len(line) // 4):
                stacks[i].append(re.sub("[^A-Za-z]+", "", line[i * 4 : i * 4 + 4]))

        # Read moves
        for line in lines[j + 1 :]:
            moves.append([int(i) for i in re.sub("[^0-9]+", " ", line).split()])

    return {k + 1: [i for i in v if i] for k, v in stacks.items()}, moves
```
{% enddetails %}


**Part 1**

Task: apply the moves and list the top item in the stack

The moves are applied in sequence using `apply_moves`.

{% details Click to expand `apply_moves` python code... %}

```python
def apply_moves(
    stacks: dict[int, list[chr]], moves: list[list[int]], reverse: bool
) -> str:
    for n, s, d in moves:
        sub = stacks[s][:n]
        stacks[d] = (sub[::-1] if reverse else sub) + stacks[d]
        stacks[s] = stacks[s][n:]
    return "".join([v[0] for k, v in stacks.items()])
```
{% enddetails %}

The reverse option is used to reorder the stack to work with the specification. For this task `reverse=True`.

**Part 2**

Task: same but with different ordering of added items.

This is solved with `apply_moves` and `reverse=False`.


## Day 06 - Tuning Trouble

[Day 06 link](https://adventofcode.com/2022/day/6)

5 examples are given.

{% details Click to expand example data... %}
```
7 mjqjpqmgbljsphdztnvjfqwrcgsmlb
5 bvwbjplbgvbhsrlpgdmjqwftvncz
6 nppdvjthqldpwncqszvftbrmjlhg
10 nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg
11 zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw
```
{% enddetails %}

Task: find message start - the first instance of four different consecutive characters.

Solution: generate the length of the `set` of n character spans until it equals n. For this [`itertools.takewhile`](https://docs.python.org/3.8/library/itertools.html#itertools.takewhile) is very useful.

{% details Click to expand `find_start` python code... %}

```python
from itertools import takewhile
def find_start(message: str, n: int) -> int:
    return n + sum(
        1
        for _ in takewhile(
            lambda x: x != n,
            map(lambda x: len(set(message[x - n : x])), range(n, len(message))),
        )
    )
```
{% enddetails %}

Plugging in `n=4` into this gives the correct solution for part 1, and part 2 likewise with `n=14`.

## Day 07 - No Space Left On Device

[Day 07 link](https://adventofcode.com/2022/day/7)

A file system is explored using `cd` and `ls`. The first `cd` is always to `/` and `ls` are always in current directory. Lines with commands starts with `$`. Listings of directories start with `dir`, and listings of file starts with file size.

{% details Click to expand example data... %}
```
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
```
{% enddetails %}

The code is read into a tree strucutre of nested dictionaries using `read_tree`. For files the value is the filesize int instead of a dictionary. I based the thinking here on my [Tree Hack blog post](https://thomasburgess.github.io/blog/2021/07/18/tree_hack.html).

{% details Click to expand `read_tree` python code... %}
```python
def read_tree(path: str) -> dict:
    tree = {}
    cwd = []
    with open(path, "r") as f:
        t = tree
        for line in f.readlines()[1:]:
            split = line.split()
            if split[0] != "$":
                # Add file or directory
                t[split[1]] = {} if split[0] == "dir" else int(split[0])
            elif split[1] == "cd":
                dest = line.split()[-1]
                # Update current working directory
                cwd = cwd[:-1] if dest == ".." else (cwd + [dest])
                t = tree
                for c in cwd:  # Jump to the right directory in the tree
                    t = t[c]
    return tree
```
{% enddetails %}

with the tree structure in place, one can traverse the tree and collect the total size of each directory. 

{% details Click to expand `read_tree` python code... %}
```python
def dir_size(tree: dict, base: str = "/") -> dict:
    result = {base: 0}
    for k, v in tree.items():
        if isinstance(v, int):
            result[base] += v
            continue
        key = base + "/" + k
        t = dir_size(v, base=key)
        result.update(t)
        result[base] += t[key]
    return result
```
{% enddetails %}

The data input for the problems is the output of `dir_size(read_data("input.txt"))`.

**Part 1** 

Task 1: Find sum of directory sizes less than 100000

Solution: sum sizes ignoring anything smaller than the threshold:

{% details Click to expand `part1` python code... %}
```python
def part1(data: dict, thresh=100000) -> int:
    return sum(v for k, v in data.items() if v < 100000)
```
{% enddetails %}

**Part 2**

Task 2: Find smallest directory that when removed leaves 30000000 free storage of a total of 70000000.

Solution: Take smallest element of items where `70000000-used+size>30000000`

{% details Click to expand `part2` python code... %}
```python
def part2(data: dict, total=70000000, req=30000000) -> int:
    return min(v for k, v in data.items() if total - data["/"] + v > req)
```
{% enddetails %}


## Day 08 - Treetop Tree House

[Day 08 link](https://adventofcode.com/2022/day/8)

Data are heights of trees on a square grid.

{% details Click to expand example data... %}
```
30373
25512
65332
33549
35390
```
{% enddetails %}

The maps are read into a list of list of ints.

{% details Click to expand `read_map` python code... %}
```python
def read_map(path: str) -> tuple[tuple[int]]:
    """Read in data into 2D int array"""
    with open(path, "r") as f:
        return tuple(tuple(map(int, i.strip())) for i in f.readlines())
```
{% enddetails %}


**Part 1** 

Task: Count number of visible trees from the edge.

Trees are not visible if behind trees of same or lower height.
The count is found as the sum of True values in a visibility matrix 
made by OR-ing together partial visibility matrices for each direction.

{% details Click to expand `part1` python code... %}
```python
def T(data: tuple[tuple[int]]) -> tuple[tuple[int]]:
    """Transpose list of lists"""
    return tuple(zip(*data))


def vor(x: list[bool], y: list[bool]) -> list[bool]:
    """Elementwise or of lists x and y"""
    return tuple(i or j for i, j in zip(x, y))


def vx(x: tuple[int]) -> tuple[bool]:
    """Visibility for each element in row x"""
    return [True] + [all(j < x[i] for j in x[:i]) for i in range(1, len(x))]


def vis(data: tuple[tuple[int]]) -> tuple[tuple[bool]]:
    """Visibilities for both directions in each row in data"""
    return tuple(vor(vx(x), vx(x[::-1])[::-1]) for x in data)


def visibility(data: tuple[tuple[int]]) -> tuple[tuple[bool]]:
    """Visibility ORed for rows and columns in data"""
    return tuple(vor(i, j) for i, j in zip(vis(data), T(vis(T(data)))))


def sum_visibility(data: tuple[tuple[int]]) -> int:
    """Sum visibilities"""
    return sum(sum(i) for i in visibility(data))
```
{% enddetails %}

**Part 2**

Task: find maximum scenic score (product number of tree visible in each direction)

Here, for each tree the number of consecutive shorter trees is counted and multiplied together for each direction. 

This task took quite some time to debug, I think I didn't parse the instructions correctly...

{% details Click to expand `part1` python code... %}
```python
def count(v0: int, v: list[int]) -> int:
    """Count trees"""
    n = 0
    for x in v:
        n += 1
        if v0 <= x:
            break
    return n


def scenic(data: tuple[tuple[int]]) -> int:
    """Compute scenic score for each tree"""
    scenic_scores = dict()
    data_t = T(data)
    r = len(data)
    c = len(data[0])
    maxx = 0
    for i in range(r):
        for j in range(c):
            x = data[i][j]
            maxx = max(
                maxx,
                count(x, data[i][:j][::-1])
                * count(x, data[i][j + 1 : c])
                * count(x, data_t[j][:i][::-1])
                * count(x, data_t[j][i + 1 : r]),
            )
    return maxx
```
{% enddetails %}

## Day 09 - Rope Bridge

[Day 09 link](https://adventofcode.com/2022/day/9)

Input data consists of moves with a direction (U,D,R,L) and a number of steps

{% details Click to expand example data... %}
```
R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
```
{% enddetails %}

The task is to move the head of a rope according to the moves, and track how the tail trails.

{% details Click to expand `read_moves` python code... %}
```python
def read_moves(path: str) -> list[tuple[str, int]]:
    with open(path, "r") as f:
        return list(
            map(lambda x: (x[0], int(x[1])), (line.split() for line in f.readlines()))
        )
```
{% enddetails %}

The solution for part2 also solves part1 so I refactored simualte accordingly. As I had several bugs, I added a handy printer function to print the rope and locations visited by the tile:

{% details Click to expand the `printer`python code... %}
```python
def printer(x: list[list[int]], hashes: bool = False):
    c = ["#" if hashes else str(i) for i in range(len(x))]
    if not hashes:
        c[0] = "H"
    sx = [s[0] for s in x]
    minx, maxx = min(sx), max(sx)
    sy = [s[1] for s in x]
    miny, maxy = min(sy), max(sy)
    for j in list(range(miny, maxy + 1))[::-1]:
        print(
            "".join(
                [
                    c[x.index([i, j])] if [i, j] in x else "."
                    for i in list(range(minx, maxx + 1))[::-1]
                ]
            )
        )
```
{% enddetails %}

The simulation is fairly straight forward, once you decode the instructions...

{% details Click to expand the solution python code... %}
```python
def sign(x: int) -> int:
    return (x > 0) - (x < 0)

def simulate(data, n=9, show=False):
    x = [[0, 0] for i in range(n + 1)]
    DELTA = {"U": (0, 1), "D": (0, -1), "R": (-1, 0), "L": (1, 0)}
    visited = {(0, 0)}
    for direction, steps in data:
        if show:
            print(f"=== {direction} {steps} ===")
        d = DELTA[direction]
        for step in range(steps):
            # Update head
            x[0] = [x[0][0] + d[0], x[0][1] + d[1]]
            # Update tail
            for i in range(1, len(x)):
                dt = [x[i - 1][0] - x[i][0], x[i - 1][1] - x[i][1]]
                if abs(dt[0]) > 1 or abs(dt[1]) > 1:
                    x[i][0] += sign(dt[0])
                    x[i][1] += sign(dt[1])
            visited.add(tuple(x[-1]))
        if show:
            printer(x)
    if show:
        print("VISITED")
        printer(list(list(x) for x in visited), hashes=True)
    return len(visited)
```
{% enddetails %}

The printer gives this expected output for the tail visits for the longer example in part 2.
```
#.....................
#.............###.....
#............#...#....
.#..........#.....#...
..#..........#.....#..
...#........#.......#.
....#......#.........#
.....#..............#.
......#............#..
.......#..........#...
........#........#....
.........########.....
```

With this code the solutions are comptuted by running:

```python
print("part 1:", read_moves("input.txt"), 1)
print("part 2:",read_moves("input.txt"), 9)
```

## Day 10 - Cathode-Ray Tube"

Data is instruction lists with `noop` (takes 1 cycle) and `addx` (takes 2 cycles). `addx dx` adds `dx` to the register x.

```
noop
addx 3
addx -5
```

The data is parsed to `cycle` count and `dx` for each instruction in `read_program`.

{% details Click to expand `read_program` python code... %}
```python
def read_program(path: str) -> list[tuple[int, int]]:
    with open(path, "r") as f:
        return [
            (1 if "noop" in l else 2, 0 if "noop" in l else int(l.split()[1]))
            for l in f.readlines()
        ]
```
{% enddetails %}

Next, the program is executed using `run_program`to track `cycle` count and `x` after each instructions. `x` starts at 1.

{% details Click to expand `run_program` python code... %}
```python
def run_program(prog: list[tuple[int, int]], x: int = 1) -> list[tuple[int, int]]:
    y = [[0, x]]
    for dt, dx in prog:
        y.append((y[-1][0] + dt, y[-1][1] + dx))
    return y
```
{% enddetails %}

**Part 1**

Task: Get cycle count * x for every 40th cycle starting at 20

The result is obtained by applying `part1` to the output of `run_program`.

{% details Click to expand `part1` python code... %}
```python
def part1(out: list[tuple[int, int]]) -> int:
    result = 0
    for q in range(20, out[-1][0], 40):
        *_, x = (q * v for (t, v) in out if t < q)
        result += x
    return result
```
{% enddetails %}


**Part 2**

Task: Draw pixels when x is within +-1 of cycle MOD 40.

The result is obtained by applying `part2` to the output of `run_program`.

{% details Click to expand `part2` python code... %}
```python
def part2(prog: list[tuple[int, int]]) -> str:
    idx = 0
    result = [" "] * 240
    for s in range(240):
        r, c = divmod(s, 40)
        if prog[idx][1] - 1 <= c <= prog[idx][1] + 1:
            result[s] = "█"
        if s > prog[idx][0]:
            idx += 1
    return "\n".join("".join(result[i * 40 : (i + 1) * 40]) for i in range(6))
```
{% enddetails %}

This part is very satisfying as you get nice output :)
```
 ██  ██  ██  ██  ██  ██  ██  ██  ██  ██
███   ███   ███   ███   ███   ███   ███
████    ████    ████    ████    ████
█████     █████     █████     █████
██████      ██████      ██████      ████
███████       ███████       ███████
```


## Day 11

**Not yet**
