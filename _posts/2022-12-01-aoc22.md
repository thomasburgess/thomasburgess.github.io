---
title: Advent of Code 2022
tags:
  - blog
  - coding
  - advent
mathjax: false
article_header:
  type: cover
categories: blog
author: thomasburgess
description: Advent of code
---

# Advent of Code 2022

I will do this years [Advent of Code 2022](https://adventofcode.com/2022) in python. I've done this a few times before, let's see how many days I manage this round :D This blog contains spoilers - use it responsibly.

In general these task requires some input data to be read in and be processed in two different parts. Here is the pathon template I use to get started:

{% details Click to expand template code... %}
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Advent of code day XX - """

def read_data(path: str) -> list:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(line)
    return result

if __name__ == "__main__":
    exdata = read_data("dayXX_example.txt")
    indata = read_data("dayXX_input.txt")

    print("PART 1")
    print("example", part1(exdata))
    print("input", part1(indata))

    print("PART 2")
    print("example", part2(exdata))
    print("input", part2(indata))
```
{% enddetails %}

I'll keep my code on this [github repository](https://github.com/thomasburgess/advent2022). 

## Day 01 - Counting calories

Lines in a group have a single integer, blank lines separate groups.

{% details Click to expand `example data` python code... %}
```
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
```
{% enddetails %}


`read_sums` parses the data, aggregates groups, and returns the list of sums.

{% details Click to expand `read_sums` python code... %}
```python
def read_sums(path):
    result = [0]  # Start with single empty sum
    with open(path, "r") as f:
        for line in f.readlines():
            if not line.strip():
                result.append(0)  # Add new empty sum
                continue
            result[-1] = result[-1] + int(line)
    return result
```
{% enddetails %}

**Part 1** 

Task: Find the group with the largest sum.

Solution: Take the maximum of the list of sums

```python
max(read_sums("day01_input.txt"))
```

**Part 2** 

Task: Find the three largest groups. 

Solution: Sort the list and summing the last 3 items:

```python
sum(sorted(read_sums("day01_input.txt"))[-3:])
```

## Day 02 - Rock Paper Scissors


Data: rows with games, the first column is the opponent move, and the second is the player move.

Move encoding: Rock, paper, and scissors is A, B, C for opponent, and X, Y, Z for player.

{% details Click to expand example data... %}
```
A Y
B X
C Z
```
{% enddetails %}

`read_strats` parses the data and converts character representation to 0, 1, 2

{% details Click to expand `read_strats` python code... %}
```python
def read_strats(path: str) -> list[int]:
    with open(path, "r") as f:
        return [
            (ord(i) - ord("A"), ord(j) - ord("X"))
            for i, j in (x.split() for x in f.readlines())
        ]
```
{% enddetails %}

**Part 1** 

Task: Count score for rock paper scissors games.

Score: Player move (1 for rock, 2 for paper, and 3 for scissors), plus 0 for loss, 3 for draw and 6 for win.

The `score` function computes the score for a single game:

{% details Click to expand `score` python code... %}
```python
def score(i, j):
    return j + 1 + [[3, 0, 6], [6, 3, 0], [0, 6, 3]][j][i]
```
{% enddetails %}

With this the total score is

```python
def part1(strats: list[int]) -> int:
    return sum(map(lambda i: score(*i), strats))
```

**Part 2**

Task: count score as above but now the second column states X=loss, Y=draw, Z=win.

Using `transform` the second column is transformed to the old format:

{% details Click to expand `transform` python code... %}
```python
def transform(i, j):
    return [[2, 0, 1], [0, 1, 2], [1, 2, 0]][j][i]
```
{% enddetails %}

and then the total score is

```python
def part2(strats: list[int]) -> int:
    return part1(map(lambda x: (x[0], transform(*x)), strats))
```

## Day 03 - Rucksack Reorganization

Each row of data is a rucksack with a string of characters `[a-zA-Z]`. 

{% details Click to expand example data... %}
```
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
```
{% enddetails %}

Each character corresponds to a priority: a=1,..., z=27, A=27,..., Z=52.

{% details Click to expand `priority` python code... %}
```python
def priority(c: chr) -> int:
    return (ord(c) - ord("A") + 27) if c.isupper() else (ord(c) - ord("a") + 1)
```
{% enddetails %}

With this sack data is read with `read_sacks`.

{% details Click to expand `read_sacks` python code... %}
```python
def read_sacks(path: str)->list[list[int]]:
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(priority, line.strip())))
    return result
```
{% enddetails %}

**Part 1**

Task: sum priority of items unique in first and second half of rucksack. 

Part 1 is solved by summing the set intersections of the first and second part of the sacks:

{% details Click to expand `part1` python code... %}
```python
def part1(sacks: list[list[int]]) -> int:
    return sum(
        map(lambda x: sum(set(x[: len(x) // 2]).intersection(x[len(x) // 2 :])), sacks)
    )

```
{% enddetails %}


**Part 2**

Task: sum priority of items unique to three consecutive rucksacks.

This part is solved by summing the intersections of  consecutive sacks, as follows:

{% details Click to expand `part2` python code... %}
```python
def part2(sacks: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: sum(
                set(sacks[x]).intersection(sacks[x + 1]).intersection(sacks[x + 2])
            ),
            range(0, len(sacks), 3),
        )
    )
```
{% enddetails %}

## Day 04 - Camp Cleanup

Each row shows a pair separated by `,`, each entry is a range `low-high`.

{% details Click to expand example data... %}
```
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
```
{% enddetails %}

With this sack data is read with `read_pairs`.

{% details Click to expand `read_pairs` python code... %}
```python
def read_pairs(path: str):
    result = []
    with open(path, "r") as f:
        for line in f.readlines():
            result.append(list(map(int, line.replace("-", ",").split(","))))
    return result
```
{% enddetails %}


**Part 1**

Task: Count pairs where one pair fully overlaps with the other

Solution: check if one pair overlaps the other in either order.

{% details Click to expand `count_contained` python code... %}
```python
def count_contained(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[2] >= x[0] and x[3] <= x[1])
            or (x[0] >= x[2] and x[1] <= x[3]),
            pairs,
        )
    )
```
{% enddetails %}

**Part 2**

Task: Count overlapping pairs

Solution: Check if range bounds overlap in any way

{% details Click to expand `count_contained` python code... %}
```python
def count_overlaps(pairs: list[list[int]]) -> int:
    return sum(
        map(
            lambda x: (x[1] >= x[2] and x[1] <= x[3])
            or (x[3] >= x[0] and x[3] <= x[1]),
            pairs,
        )
    )
```
{% enddetails %}

## Day 05 - Supply Stacks

The data is split into two parts separated by a blank line. In the first part, stacks of items are listed in columns, with column index on the last row (this index can be ignored). Items are on the form `[X]` where `X` is a single character item id. In the second part a sequence of moves with item count count, source column, destination column are listed.

{% details Click to expand example data... %}
```
    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
```
{% enddetails %}

The two parts are read in and processed with `read_stacks`:

{% details Click to expand `read_stacks` python code... %}

```python
def read_stacks(path: str) -> tuple[dict[int, list[chr]], list[list[int]]]:
    stacks = defaultdict(list)
    moves = []
    with open(path, "r") as f:
        lines = f.readlines()

        # Read stacks
        for j, line in enumerate(lines):
            if line == "\n":
                break
            for i in range(len(line) // 4):
                stacks[i].append(re.sub("[^A-Za-z]+", "", line[i * 4 : i * 4 + 4]))

        # Read moves
        for line in lines[j + 1 :]:
            moves.append([int(i) for i in re.sub("[^0-9]+", " ", line).split()])

    return {k + 1: [i for i in v if i] for k, v in stacks.items()}, moves
```
{% enddetails %}


**Part 1**

Task: apply the moves and list the top item in the stack

The moves are applied in sequence using `apply_moves`.

{% details Click to expand `apply_moves` python code... %}

```python
def apply_moves(
    stacks: dict[int, list[chr]], moves: list[list[int]], reverse: bool
) -> str:
    for n, s, d in moves:
        sub = stacks[s][:n]
        stacks[d] = (sub[::-1] if reverse else sub) + stacks[d]
        stacks[s] = stacks[s][n:]
    return "".join([v[0] for k, v in stacks.items()])
```
{% enddetails %}

The reverse option is used to reorder the stack to work with the specification. For this task `reverse=True`.

**Part 2**

Task: same but with different ordering of added items.

This is solved with `apply_moves` and `reverse=False`.


## Day 06 - Tuning Trouble

5 examples are given.

{% details Click to expand example data... %}
```
7 mjqjpqmgbljsphdztnvjfqwrcgsmlb
5 bvwbjplbgvbhsrlpgdmjqwftvncz
6 nppdvjthqldpwncqszvftbrmjlhg
10 nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg
11 zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw
```
{% enddetails %}

Task: find message start - the first instance of four different consecutive characters.

Solution: generate the length of the `set` of n character spans until it equals n.

{% details Click to expand `find_start` python code... %}

```python
def find_start(message: str, n: int) -> int:
    return n + sum(
        1
        for _ in takewhile(
            lambda x: x != n,
            map(lambda x: len(set(message[x - n : x])), range(n, len(message))),
        )
    )
```
{% enddetails %}

Plugging in `n=4` into this gives the correct solution for part 1, and part 2 likewise with `n=14`.

## Day 07 
**Not yet**
